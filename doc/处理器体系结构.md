指令集架构体系（ISA）：一个处理器支持的指令和指令的字节集编码

ISA在编译器编写者和处理器设计人员之间提供了一个概念抽象层，编译器编写者只要知道允许哪些指令，以及他们是如何编码的；而处理器设计者必须构建出执行这些指令的处理器

一个程序编译成在一种机器上运行，就不能在另一种机器上允许


硬件控制语言（HCL）

指令集体系结构包括：定义各种状态单元、指令集和他们的编码、一组程序规范和异常事件处理


### 程序员可见状态
程序中的每条指令都会读取或修改处理器状态的某些部分，这称之为程序员可见状态。主要包括：寄存器,存储器,条件码,PC,程序状态

寄存器：一共有15个寄存器（%rax、%rcx、%rdx、%rbx、%rsp、%rbp、%rsi、%rdi、%r8、%r9、%r10、%r11、%r12、%r13、%r14），每个程序寄存器存储一个64位的字。寄存器%rsp被入栈、出栈、调用和返回指令作为栈指针，其余没有固定含义或固定值

条件码:有3个一位的条件码：ZF、SF、OF（零、符号、溢出），保存最近的算术或逻辑指令所造成影响的有关信息

程序计数器（PC）：存放当前正在执行指令的地址

内存：从概念上来说是一个很大的字节数组，保存着程序和数据

程序状态：表明程序执行的总体状态，它会指示是正常运行，还是出现了某种异常。


### 指令编码
每个指令都有字节级编码。每条指令需要1\~10个字节不等，取决于需要哪些字段。
首先，可能有附加的寄存器指示符字节，指定一个或两个寄存器。
根据指令类型，指令可以指定用于数据源和目的的寄存器，或是用于地址计算的基址寄存器。
没有基址寄存器的操作，就没有寄存器指示符字节。
只需要一个寄存器操作数的指数，根据约定将另一个寄存器指示符设为0xF。
每条指令的第一个字节表明指令的类型。这个字节分为两个部分，每个部分4位：高4位是代码（code）部分，低4位是功能（function）部分。代码只为0\~0xB。功能值只有在一组相关指令公用一个代码时才有用。

指令集的一个重要性质是字节编码必须有唯一的解释。任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。这个性质保证了处理器可以无二义性地执行目标代码程序。即使代码嵌入在程序的其他字节中，只要从序列的第一个字节开始处理，我们仍然可以很容易的确定怎样将序列划分成单独的指令，反过来说，如果不知道一段代码序列的起始位置，我们就不能准确地确定怎样将序列划分成单独的指令。


### RISC和CISC指令集
CISC：复杂指令集计算机。先出现CISC机器，随着机器设计者加入了很多新指令来支持高级任务，大型机和小型机的指令负责度一直在增加。
RISC：精简指令集计算机。一些专家认为他们可以为更简单的指令集形式产生高效的代码。实际上，许多加到指令集中的高级指令很难被编译器产生，所以也很少被用到。一个较为简单的指令集可以用很少的硬件实现，能以进高效流水线结构组织起来。

RISC与CISC优缺点的争论十分激烈，RISC的支持者声称在给定硬件数量的情况下，可以结合简约式指令集设计、高级编译器技术和流水线的处理器实现，他们能够得到更强的计算能力。而CISC的拥趸者反驳说要完成已给定的任务只需要用较少的CISC指令，所以他们的机器能够获得更高的总体性能。事实证明，无论是单纯的RISC还是单纯的CISC都不如结合两者思想精华的设计。

### 异常
程序的状态码描述了程序执行的总体状态，可能的值如下：
| 值 | 名称 | 含义 |
| - | - | - |
| 1 | AOK | 正常操作 |
| 2 | HLT | 遇到处理器执行了halt指令 |
| 3 | ADR | 遇到非法地址 |
| 4 | INS | 遇到非法指令 |

当遇到异常时，处理器通常会调用一个异常处理程序，这个过程被指定用来处理遇到的某种类型的异常。


### 逻辑设计和硬件控制语言HCL
在硬件设计中，用电子电路来计算对位进行运算的函数，以及在各种存储单元中存储位。大多数现代电路技术都是用信号线上的高电压和低电压来表示不同的位置。在当前的技术中，逻辑1是用1.0伏特左右的高电压表示的，而逻辑0是用0.0伏特左右的低电压表示的。要实现一个数字系统需要三个主要的组成部分：计算对位进行操作的函数的组合逻辑、存储位的存储单元，以及控制存储器单元更新的时钟信号。

#### 逻辑门
逻辑门是数字电路的基本计算单元。它们产生的输出，等于它们输入位置的某个布尔函数。逻辑门只对单个位的数进行操作。逻辑门总是活动的，一旦一个门的输入变化了，在很短的时间内，输出就会相应地变化。

#### 组合电路和HCL布尔表达式
将很多的逻辑门组合成一个网，就能构建计算块，称为组合电路。如何构建这些网有几个限制：
+ 每个逻辑门的输入必须连接到下述选项之一：1、一个系统输入（称为主输入）；2、某个存储器单元的输出；3、某个逻辑门的输出
+ 两个或多个逻辑门的输出不能连接在一起。否则他们可能会是线上的信号矛盾，可能会导致一个不合法的电压或电路故障。
+ 这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，这样的回路会导致该网络计算的函数有歧义。

##### 多路复用电路
多路复用电路根据输入控制信号的值，从一组不同的数据信号中选出一个。
在这个单个位的多路复用器中，两个数据信号是输入位a和b，控制信号是输入位s。当s为1时，输出等于a，；而当s为0时，输出等于b。在这个电路中国，我们可以看出两个AND门决定了是否将它们相对应的数据输入传送到OR门。当s为0时，上面的AND门将传送信号b（因为这个门的另一个输入是!s），而当s是1时，下面的AND门将传送信号a。
<pre><code>bool out = (s && a) || (!s && b);</code></pre>

HCL表达式很清楚的表明了组合逻辑电路和C语言中逻辑 表达式的对应之处。它们都是用布尔操作来对输入进行计算的函数。值得注意的是，这两种表达式计算的方法之间有以下区别：
+ 因为组合电路是有一系列的逻辑门组成，它的属性是输出会持续地响应输入的变化。如果电路的输入变化了，在一定的延迟之后，输出也会相应地变化。相比之下，C表达式只会在程序执行过程中被遇到时才进行求值
+ C的逻辑表达式允许参数是任意整数，0表示FALSE，其他任何值都可表示TRUE。而逻辑门只对值0和1进行操作
+ C的逻辑表达式有个属性就是他们坑你只被部分求值。如果一个AND或OR操作的结构只用对第一个参数求值就能确定，那么久不会对第二个参数求值。例如下面的C表达式`(a && !a) && func(b,c)`，这里函数func是不会调用的，因为表达式(a && !a)求值为0。而组合逻辑没有部分求值这条规则，逻辑门只是简单地响应输入的变化。


通过将逻辑门组合成大的网，可以构造出能计算更加复杂函数的组合电路。通常，我们设计能对数据字进行操作的电路。有一些位级信号，代表一个整数或一些控制模式。
##### 字级组合电路
执行字级计算的组合电路根据输入字的各个位，用逻辑门来计算输出字的各个位。这些单个位电路的输出用一个AND们连起来，形成了这个电路的输出。

##### HCL整数表达式




### 存贮器和时钟
组合电路本质上讲，不存储任何信息。相反，它们只是简单地响应输入信号，产生等于输入的某个函数的输出。为了产生时序电路，也就是有状态并且在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。存储设备都是由同一个时钟控制的，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。考虑两类存储器设备：
+ 时钟寄存器（简称寄存器）存储单个位或字。时钟信号控制寄存器加载输入值
+ 随机访问存储器（简称内存）存储多个字，用地址来选择该读或该写哪个字。随机访问存贮器的例子包括：1）处理器的虚拟内存系统，硬件和操作系统软件结合起来使处理器可以再已很大的地址空间内访问任意的字；2）寄存器文件，在此，寄存器标志符作为地址。

> 再说到硬件和机器级编程时，“寄存器”这个词是两个有细微差别的事情。在硬件中，寄存器直接将它的输入和输出链接到电路的其他部分。在机器级编程中，寄存器代表的是CPU中为数不多的可寻址的字，这里的地址时寄存器ID。这些字通常都存在寄存器文件中，虽然我们会看到硬件有时可以直接将一个字从一个指令传送到另一个指令，以避免先写寄存器文件再到读出来的延迟。需要避免歧义时，我们会分别称呼这两类寄存器为“硬件寄存器”和“程序寄存器”


大多数时候，寄存器都保持在稳定状态（有x表示），产生的输出等于它的当前状态。信号沿着寄存器前面的组合逻辑传播，这是，产生一个新的寄存器输入（用y表示），但只要时钟是低电位的，寄存器的输出就仍然保持不变。当时钟变成高电位的时候，输入信号就加载到寄存器中，成为下一个状态y，直到下一个时钟上升沿，这个状态就一直是寄存器的新输出。关键是寄存器是作为电路不同部分中的组合逻辑之间的屏障。每当每个时钟到达上升沿时，值才会从寄存器的输入传送到输出。

处理器会用时钟寄存器保存程序计数器（PC）、条件代码（CC）和程序状态（Stat）

寄存器文件有两个读端口，还有一个写端口。这样一个多端口堆积访问存储器允许同时进行多个读和写操作。每个端口都有一个地址输入，表明该选择哪个程序寄存器，另外还有一个输入输出或对应程序寄存器的输入值。

虽然寄存器文件不是组合电路，因为它有内部存储。不过，从寄存器文件读数据就好像他是以一个地址为输入、数据为输出的一个组合逻辑块。

向寄存器文件写入字是由时钟信号控制的，控制的方式类似于将值加载到时钟寄存器。每次时钟上升时，输入valW上的值会被写入dstW上的寄存器ID指示的程序寄存器。当DSTW设为特殊的ID值OxF时，不会写入任何程序寄存器。由于寄存器文件既可以读也可以写，如果更新一个寄存器，同时在读端口上用同一个寄存器ID，我们会看到一个从旧值到新值的变化。

处理器有一个随机访问存储器来存储程序数据，这个内存有一个地址输入，已写的数据输出，以及一个读的数据输出。同寄存器文件一样，从内存中的的操作方式类似于组合逻辑：如果我们在一个输入address上提供一地址，并将write控制信号设置为0，那么经过一段延迟之后，存储在哪个地址上的值会出现在输出data上。如果地址超出了范围，error信号会设置为1，否则就设置为0.写内存是有时钟控制的：我们将address设置为期望的地址，将data in 设置为期望的值，而write设置为1。然后当我们控制时钟时，只要地址时合法的，就会更新内存中指定的位置。对于读操作来说，如果地址是不合法的，error信号就会设置为1。这个信号是由组合逻辑产生的，因为所需要的边界检查纯粹就是地址输入的函数，不涉及保存任何状态。
